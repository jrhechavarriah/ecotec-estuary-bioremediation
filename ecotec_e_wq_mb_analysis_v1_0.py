# -*- coding: utf-8 -*-
"""ECOTEC_E_WQ_MB_Analysis_v1_0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1enOIRJgSWKvYwSzzCTsIEM8a9y4UeXCU
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import os

# =============================================================================
# 0. CONFIG
# =============================================================================

DATA_FILE = "/content/ECOTEC_Estuary_WQ_MBio_2024-2025.csv"
OUTPUT_DIR = "output_figures_tables"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# =============================================================================
# 1. LOAD RAW DATA
# =============================================================================

df_raw = pd.read_csv(DATA_FILE)

print("\n================ RAW DATA ================")
print(df_raw.head())
print("\nShape:", df_raw.shape)
print("\nColumns in raw file:", list(df_raw.columns))

# =============================================================================
# 2. BASIC CLEANING AND NORMALIZATION
# =============================================================================

df = df_raw.copy()

# --- Strip whitespace from ALL column names (very important) ---
df.columns = [c.strip() for c in df.columns]

print("\nColumns after stripping spaces:", list(df.columns))

# --- Robust detection of Station and Date columns ---
station_col = None
date_col = None

for c in df.columns:
    cname = (
        str(c)
        .strip()
        .lower()
        .replace(" ", "")
        .replace("\ufeff", "")  # remove BOM if present
    )
    if cname in ["station_id", "stationid", "station", "estacion_id", "estacion"]:
        station_col = c
    if cname in ["date", "fecha", "samplingdate"]:
        date_col = c

if station_col is None:
    raise ValueError(
        f"Could not detect station column. Columns found: {list(df.columns)}"
    )
if date_col is None:
    raise ValueError(
        f"Could not detect date column. Columns found: {list(df.columns)}"
    )

print(f"\nDetected station column: {station_col}")
print(f"Detected date column: {date_col}")

# Rename to unified English names
df = df.rename(columns={station_col: "Station", date_col: "Date"})

# --- Date column ---
df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
df["Date"] = df["Date"].ffill()   # forward-fill just in case

# Replace any legacy markers like "--" with NaN
df = df.replace("--", np.nan)

# Ensure Station is a clean categorical variable
df["Station"] = df["Station"].astype(str).str.strip()
df["Station"] = df["Station"].astype("category")

# Numeric columns in the *English* dataset (after stripping col names)
numeric_columns = [
    "DO_pct",
    "Nitrite_mgL",
    "Nitrate_mgL",
    "COD_mgL",
    "BOD_mgL",
    "Ammonium_mgL",
    "TP_mgL",
    "TKN_mgL",
    "SulfideH2S_mgL",
    "TotalAlkalinity_mgL",
    "Salinity_pct",
]

for col in numeric_columns:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors="coerce")

# Time variable: days since the beginning of the monitoring campaign
df["days_since_start"] = (df["Date"] - df["Date"].min()).dt.days

# Sort rows by station and date
df = df.sort_values(["Station", "Date"]).reset_index(drop=True)

print("\n===== CLEANED DATA (HEAD) =====")
print(df.head())
print("\nStations:", df["Station"].unique())

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import os

# =============================================================================
# 0. CONFIG
# =============================================================================

DATA_FILE = "/content/ECOTEC_Estuary_WQ_MBio_2024-2025.csv"
OUTPUT_DIR = "output_figures_tables"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# =============================================================================
# 1. LOAD RAW DATA
# =============================================================================

df_raw = pd.read_csv(DATA_FILE)

print("\n================ RAW DATA ================")
print(df_raw.head())
print("\nShape:", df_raw.shape)
print("\nColumns in raw file:", list(df_raw.columns))

# =============================================================================
# 2. BASIC CLEANING AND NORMALIZATION
# =============================================================================

df = df_raw.copy()

# 2.1 Strip whitespace from ALL column names (very important)
df.columns = [c.strip() for c in df.columns]

print("\nColumns after stripping spaces:", list(df.columns))

# 2.2 Detect Station and Date columns
station_col = None
date_col = None

for c in df.columns:
    cname = (
        str(c)
        .strip()
        .lower()
        .replace(" ", "")
        .replace("\ufeff", "")  # remove BOM if present
    )
    if cname in ["station_id", "stationid", "station", "estacion_id", "estacion"]:
        station_col = c
    if cname in ["date", "fecha", "samplingdate"]:
        date_col = c

if station_col is None:
    raise ValueError(
        f"Could not detect station column. Columns found: {list(df.columns)}"
    )
if date_col is None:
    raise ValueError(
        f"Could not detect date column. Columns found: {list(df.columns)}"
    )

print(f"\nDetected station column: {station_col}")
print(f"Detected date column: {date_col}")

# 2.3 Rename to unified names
df = df.rename(columns={station_col: "Station", date_col: "Date"})

# 2.4 Date handling
df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
df["Date"] = df["Date"].ffill()   # forward-fill just in case

# 2.5 Replace legacy markers like "--" with NaN
df = df.replace("--", np.nan)

# 2.6 Ensure Station is a clean categorical variable
df["Station"] = df["Station"].astype(str).str.strip()
df["Station"] = df["Station"].astype("category")

# 2.7 Numeric columns in the English dataset
numeric_columns = [
    "DO_pct",
    "Nitrite_mgL",
    "Nitrate_mgL",
    "COD_mgL",
    "BOD_mgL",
    "Ammonium_mgL",
    "TP_mgL",
    "TKN_mgL",
    "SulfideH2S_mgL",
    "TotalAlkalinity_mgL",
    "Salinity_pct",
]

for col in numeric_columns:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors="coerce")

# 2.8 Time variable: days since start
df["days_since_start"] = (df["Date"] - df["Date"].min()).dt.days

# 2.9 Sort rows by station and date
df = df.sort_values(["Station", "Date"]).reset_index(drop=True)

print("\n===== CLEANED DATA (HEAD) =====")
print(df.head())
print("\nStations:", df["Station"].unique())

# =============================================================================
# 3. EFFICIENCY CALCULATION BY STATION
# =============================================================================

# Baseline = first measurement per station (by Date)
# We assume baseline is the earliest Date for that station.

# Sort again for safety
df = df.sort_values(["Station", "Date"]).reset_index(drop=True)

baseline_nh3 = df.groupby("Station")["Ammonium_mgL"].transform("first")
baseline_cod = df.groupby("Station")["COD_mgL"].transform("first")
baseline_bod = df.groupby("Station")["BOD_mgL"].transform("first")

df["Ammonium_baseline_mgL"] = baseline_nh3
df["COD_baseline_mgL"] = baseline_cod
df["BOD_baseline_mgL"] = baseline_bod

# Efficiency (%) = (baseline - current) / baseline * 100
# If baseline is 0 → result will be NaN or inf; that's OK (we can filter/interpret later).
df["Eff_NH3_pct"] = (df["Ammonium_baseline_mgL"] - df["Ammonium_mgL"]) / df["Ammonium_baseline_mgL"] * 100
df["Eff_COD_pct"] = (df["COD_baseline_mgL"]      - df["COD_mgL"])      / df["COD_baseline_mgL"]      * 100
df["Eff_BOD_pct"] = (df["BOD_baseline_mgL"]      - df["BOD_mgL"])      / df["BOD_baseline_mgL"]      * 100

print("\n===== SAMPLE WITH EFFICIENCY =====")
print(df[["Date","Station","Ammonium_mgL","Eff_NH3_pct","Eff_COD_pct","Eff_BOD_pct"]].head(10))

# =============================================================================
# 4. PHASE VARIABLE: INITIAL vs MONITORING
# =============================================================================

# For each station, the earliest date is considered "Initial", others "Monitoring"
df["Phase"] = "Monitoring"
first_dates = df.groupby("Station")["Date"].transform("min")
df.loc[df["Date"] == first_dates, "Phase"] = "Initial"

print("\nPhase counts by station:")
print(df.groupby(["Station","Phase"])["Date"].count())

# =============================================================================
# 5. TABLES (Water Research style, in English)
# =============================================================================

# --------------------------
# Table 1 – Station-wise summary of main variables
# --------------------------
variables_main = [
    "Ammonium_mgL",
    "COD_mgL",
    "BOD_mgL",
    "Nitrite_mgL",
    "Nitrate_mgL",
    "DO_pct",
    "Salinity_pct",
]

table1 = (
    df
    .groupby("Station")[variables_main]
    .agg(["mean", "std", "min", "max", "count"])
)

table1_rounded = table1.round(3)
print("\n===== TABLE 1 – Station-wise summary (rounded) =====")
print(table1_rounded)

table1_csv = os.path.join(OUTPUT_DIR, "Table1_StationSummary.csv")
table1_rounded.to_csv(table1_csv)
print(f"\nTable 1 saved to: {table1_csv}")

# --------------------------
# Table 2 – Station-wise efficiency summary (NH3, COD, BOD)
# --------------------------
variables_eff = ["Eff_NH3_pct", "Eff_COD_pct", "Eff_BOD_pct"]

table2 = (
    df
    .groupby("Station")[variables_eff]
    .agg(["mean", "std", "min", "max", "count"])
)

table2_rounded = table2.round(2)
print("\n===== TABLE 2 – Station-wise removal efficiency (%) =====")
print(table2_rounded)

table2_csv = os.path.join(OUTPUT_DIR, "Table2_EfficiencyByStation.csv")
table2_rounded.to_csv(table2_csv)
print(f"\nTable 2 saved to: {table2_csv}")

# --------------------------
# Table 3 – Initial vs Monitoring (per station, per phase)
# --------------------------
table3 = (
    df
    .groupby(["Station", "Phase"])[["Ammonium_mgL","COD_mgL","BOD_mgL"]]
    .agg(["mean", "std", "min", "max", "count"])
)

table3_rounded = table3.round(3)
print("\n===== TABLE 3 – Initial vs Monitoring (Ammonium, COD, BOD) =====")
print(table3_rounded)

table3_csv = os.path.join(OUTPUT_DIR, "Table3_PhaseComparison.csv")
table3_rounded.to_csv(table3_csv)
print(f"\nTable 3 saved to: {table3_csv}")

print("\n✅ All tables have been generated in the folder:", OUTPUT_DIR)

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# 1. Coordenadas de las estaciones
# -------------------------------

# Formato: "nombre": (latitud, longitud)
stations = {
    "E1": (-2.1504524442872683, -79.90386509307386),
    "E2": (-2.150425641089682, -79.9036317408747),
    "E3": (-2.1507781031339674, -79.90312480337113),
    "E4": (-2.151149327332683, -79.90247302657993),
    "E5": (-2.1514991088976423, -79.90149804361434),
}

# ---------------------------------------
# 2. Conversión a coordenadas locales (m)
#    Aproximación plana alrededor del sitio
# ---------------------------------------

# Tomamos la primera estación como origen
lat0, lon0 = stations["E1"]

# Convertimos grados a radianes para el cálculo
lat0_rad = np.deg2rad(lat0)

# Factores de conversión (aprox.)
m_per_deg_lat = 111_320  # ~111.32 km por grado de latitud
m_per_deg_lon = 111_320 * np.cos(lat0_rad)

# Función para convertir (lat, lon) a (x, y) en metros relativos a E1
def latlon_to_local(lat, lon, lat0=lat0, lon0=lon0):
    dy = (lat - lat0) * m_per_deg_lat      # norte (+) / sur (−)
    dx = (lon - lon0) * m_per_deg_lon      # este (+) / oeste (−)
    return dx, dy

# Construimos arrays de posiciones
xs = []
ys = []
labels = []

for name, (lat, lon) in stations.items():
    dx, dy = latlon_to_local(lat, lon)
    xs.append(dx)
    ys.append(dy)
    labels.append(name)

xs = np.array(xs)
ys = np.array(ys)

# ---------------------------------------
# 3. Crear figura estilo “mapa científico”
# ---------------------------------------

fig, ax = plt.subplots(figsize=(6, 6))

# Dibujar líneas conectando las estaciones (perfil del estero)
# Ordenamos según la longitud (o según el orden lógico E1→E2→E3→E4→E6)
order = ["E1", "E2", "E3", "E4", "E5"]
xs_order = []
ys_order = []
for name in order:
    lat, lon = stations[name]
    dx, dy = latlon_to_local(lat, lon)
    xs_order.append(dx)
    ys_order.append(dy)

ax.plot(xs_order, ys_order, "-o", linewidth=1.5, markersize=6, color="black")

# Dibujar puntos y etiquetas de estaciones
for name, x, y in zip(labels, xs, ys):
    ax.scatter(x, y, s=30, color="black")
    ax.text(x + 2, y + 2, name, fontsize=9, ha="left", va="bottom")

# Ajustar aspecto: igual en ambos ejes (escala métrica real)
ax.set_aspect("equal", adjustable="box")

# Limitar un poco los márgenes alrededor de los puntos
padding = 15  # metros
ax.set_xlim(xs.min() - padding, xs.max() + padding)
ax.set_ylim(ys.min() - padding, ys.max() + padding)

# ---------------------------------------
# 4. Barra de escala (50 m)
# ---------------------------------------

scale_length = 50  # metros
# Posición de la barra de escala (esquina inferior izquierda)
x0 = xs.min() + 5
y0 = ys.min() + 5

ax.plot([x0, x0 + scale_length], [y0, y0], "k-", linewidth=2)
ax.text(x0 + scale_length / 2, y0 + 3, "50 m", ha="center", va="bottom", fontsize=10)

# ---------------------------------------
# 5. Flecha de Norte
# ---------------------------------------

# Posición de la flecha (esquina superior izquierda)
xn = xs.min() + 10
yn = ys.max() - 10

# Flecha apuntando hacia arriba (Norte)
ax.annotate(
    "",
    xy=(xn + 220, yn + 20),  # punta
    xytext=(xn + 220, yn),   # base
    arrowprops=dict(arrowstyle="simple", color="black")
)
ax.text(xn + 220, yn + 23, "N", ha="center", va="bottom", fontsize=10)

# ---------------------------------------
# 6. Estilo final del mapa
# ---------------------------------------

# Etiquetas de ejes (si quieres que se vea que son metros locales)
ax.set_xlabel("X (m, along-channel distance relative to S1)", fontsize=10)
ax.set_ylabel("Y (m, cross-channel offset relative to S1)", fontsize=10)

# Quitar grid para estilo más limpio
ax.grid(False)

# Opcional: suavizar los spines
for spine in ["top", "right"]:
    ax.spines[spine].set_visible(False)

#ax.set_title("Sampling stations along the Ecotec University estuary", fontsize=11)

plt.tight_layout()
plt.savefig("Fig1_map.png", dpi=300, bbox_inches="tight")
plt.show()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates

# ================================
# Figure 2 – Time series panel (2×2)
# ================================

def plot_series_panel(ax, var, ylabel, title):
    """Plot a variable by station on a given axis."""
    for st, df_st in df.groupby("Station"):
        df_st = df_st.sort_values("Date")
        ax.plot(df_st["Date"], df_st[var], marker="o", label=f"Station {st}")
    ax.set_ylabel(ylabel)
    ax.set_title(title, fontsize=10)
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m"))

# Crear figura y ejes 2x2
fig, axes = plt.subplots(2, 2, figsize=(10, 8), sharex=True)
ax1, ax2, ax3, ax4 = axes.ravel()

# (a) Ammonium
plot_series_panel(
    ax1,
    var="Ammonium_mgL",
    ylabel="Ammonium (mg/L)",
    title="(a) Ammonium time series"
)

# (b) Nitrate
plot_series_panel(
    ax2,
    var="Nitrate_mgL",
    ylabel="Nitrate (mg/L)",
    title="(b) Nitrate time series"
)

# (c) COD
plot_series_panel(
    ax3,
    var="COD_mgL",
    ylabel="COD (mg/L)",
    title="(c) COD time series"
)

# (d) BOD
plot_series_panel(
    ax4,
    var="BOD_mgL",
    ylabel="BOD (mg/L)",
    title="(d) BOD time series"
)

# Etiqueta común en el eje X
for ax in axes[1, :]:
    ax.set_xlabel("Date")

# Rotar fechas
fig.autofmt_xdate(rotation=45)

# Leyenda global (todas las estaciones)
handles, labels = ax1.get_legend_handles_labels()
fig.legend(handles, labels, loc="lower center", ncol=len(labels), frameon=False)

# Ajustar layout dejando espacio para la leyenda abajo
plt.tight_layout(rect=(0, 0.05, 1, 1))

# Guardar figura panel
plt.savefig("Fig2_panel_timeseries.png", dpi=300)
plt.show()

import matplotlib.pyplot as plt

# ======================================
# 1. Crear columna Fase (Initial vs Monitoring)
# ======================================

# Suponemos que df ya viene del script anterior y tiene columnas:
# Date, Station, Ammonium_mgL, COD_mgL, BOD_mgL, etc.

df = df.sort_values(["Station", "Date"]).reset_index(drop=True)

# Fecha mínima por estación = muestreo inicial
first_dates = df.groupby("Station")["Date"].transform("min")

# Fase: Initial si es la primera fecha de esa estación, Monitoring en el resto
df["Phase"] = np.where(df["Date"] == first_dates, "Initial", "Monitoring")

print(df[["Date", "Station", "Ammonium_mgL", "COD_mgL", "BOD_mgL", "Phase"]].head(10))

# ======================================
# 2. Figure 3 – Boxplots Initial vs Monitoring (3×1)
# ======================================

def add_boxplot(ax, var, ylabel, title):
    """Generate boxplot by Phase on a specific axis."""
    df.boxplot(column=var, by="Phase", ax=ax)
    ax.set_title(title, fontsize=10)
    ax.set_ylabel(ylabel)
    ax.set_xlabel("")          # remove default x-label
    ax.figure.suptitle("")     # remove automatic pandas suptitle

# Create figure and axes
fig, axes = plt.subplots(3, 1, figsize=(7, 10))
ax1, ax2, ax3 = axes

# (a) Ammonium
add_boxplot(
    ax1,
    var="Ammonium_mgL",
    ylabel="Ammonium (mg/L)",
    title="(a) Ammonium: Initial vs Monitoring"
)

# (b) COD
add_boxplot(
    ax2,
    var="COD_mgL",
    ylabel="COD (mg/L)",
    title="(b) COD: Initial vs Monitoring"
)

# (c) BOD
add_boxplot(
    ax3,
    var="BOD_mgL",
    ylabel="BOD (mg/L)",
    title="(c) BOD: Initial vs Monitoring"
)

plt.tight_layout()
plt.savefig("Fig3_panel_boxplots.png", dpi=300)
plt.show()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates

# ================================
# Figure 4 – Removal efficiencies panel (3×1)
# ================================

def plot_eff_panel(ax, var, ylabel, title):
    """Plot removal efficiency by station on a given axis."""
    for est, df_est in df.groupby("Station"):
        df_est = df_est.sort_values("Date")
        ax.plot(df_est["Date"], df_est[var], marker="o", label=f"S{est}")
    ax.axhline(0, color="gray", linestyle="--")
    ax.set_ylabel(ylabel)
    ax.set_title(title, fontsize=10)
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%d-%m"))

# Crear figura y ejes 3x1
fig, axes = plt.subplots(3, 1, figsize=(9, 9), sharex=True)
ax1, ax2, ax3 = axes

# (a) Ammonium removal efficiency
plot_eff_panel(
    ax1,
    var="Eff_NH3_pct",
    ylabel="Ammonium removal (%)",
    title="(a) Ammonium removal efficiency by station"
)

# (b) COD removal efficiency
plot_eff_panel(
    ax2,
    var="Eff_COD_pct",
    ylabel="COD removal (%)",
    title="(b) COD removal efficiency by station"
)

# (c) BOD removal efficiency
plot_eff_panel(
    ax3,
    var="Eff_BOD_pct",
    ylabel="BOD removal (%)",
    title="(c) BOD removal efficiency by station"
)

# Etiqueta común en el eje X
ax3.set_xlabel("Date")

# Rotar fechas
fig.autofmt_xdate(rotation=45)

# Leyenda global (una sola)
handles, labels = ax1.get_legend_handles_labels()
fig.legend(handles, labels, loc="lower center", ncol=len(labels), frameon=False)

# Ajustar layout dejando espacio para la leyenda
plt.tight_layout(rect=(0, 0.05, 1, 1))

# Guardar figura panel
plt.savefig("Fig4_panel_efficiencies.png", dpi=300)
plt.show()

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Configuración general
plt.rcParams.update({
    "font.family": "sans-serif",
    "font.size": 10
})

# Crear figura y ejes
fig, ax = plt.subplots(figsize=(13.3, 2))  # Tamaño proporcional ~1328x531 px

# Definir los pasos
steps = [
    ("Multi-station\nsampling", "~"),
    ("Disturbance–\nrecovery protocol", "T"),
    ("APHA\nlaboratory analysis", "▮"),
    ("Python\nworkflow", "▌▐"),
    ("Bioremediation\nassessment", "✓")
]

# Colores para íconos
icon_colors = ["#264653", "#264653", "black", "#264653", "green"]

# Crear bloques
block_width = 2.5
for i, (title, icon) in enumerate(steps):
    x0 = i * block_width
    # Caja
    box = patches.FancyBboxPatch((x0, 0), block_width, 2,
                                 boxstyle="round,pad=0.02",
                                 linewidth=1.2,
                                 edgecolor="black",
                                 facecolor="#E6F0FB")
    ax.add_patch(box)

    # Texto del paso
    ax.text(x0 + block_width/2, 1.6, title,
            ha="center", va="center", fontsize=10)

    # Icono representativo
    ax.text(x0 + block_width/2, 0.7, icon,
            ha="center", va="center", fontsize=18, color=icon_colors[i])

    # Flechas (menos para el último)
    if i < len(steps) - 1:
        ax.annotate("",
                    xy=(x0 + block_width, 1),
                    xytext=(x0 + block_width - 0.1, 1),
                    arrowprops=dict(arrowstyle="->", linewidth=1.2))

# Ajustes finales
ax.set_xlim(-0.2, len(steps) * block_width + 1)
ax.set_ylim(-0.1, 2.2)
ax.axis("off")

# Guardar como SVG + PNG
plt.savefig("graphical_abstract_methodsx.svg", format="svg", bbox_inches="tight")
plt.savefig("graphical_abstract_methodsx.png", dpi=300, bbox_inches="tight")
plt.show()

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Crear figura y ejes
fig, ax = plt.subplots(figsize=(4, 4))

# -----------------------------
# 1. Columna de agua y sedimento
# -----------------------------

# Rectángulo de la columna de agua
water = patches.Rectangle(
    (0.2, 0.2),   # (x, y)
    0.6,          # ancho
    0.6,          # alto
    linewidth=2,
    edgecolor="black",
    facecolor="none"
)
ax.add_patch(water)

# Línea de sedimento
ax.hlines(0.25, 0.2, 0.8, linewidth=2)
ax.text(0.82, 0.23, "Sediment", fontsize=8, va="center")

# Etiqueta de Agua
ax.text(0.22, 0.78, "Water\ncolumn", fontsize=8, va="top")

# -----------------------------
# 2. Vara entrando en el sedimento
# -----------------------------

ax.plot([0.5, 0.5], [0.2, 0.7], color="black", linewidth=3)
ax.text(0.53, 0.21, "Pole", fontsize=8, va="bottom")

# -----------------------------
# 3. Flechas de golpes verticales
# -----------------------------

ax.annotate("", xy=(0.5, 0.7), xytext=(0.5, 0.55),
            arrowprops=dict(arrowstyle="->", linewidth=0.8))#1.5
ax.annotate("", xy=(0.5, 0.55), xytext=(0.5, 0.7),
            arrowprops=dict(arrowstyle="->", linewidth=0.8))#1.5
ax.text(0.55, 0.63, "Vertical\nstrokes", fontsize=8, va="center")

# -----------------------------
# 4. Flecha de rotaciones circulares
# -----------------------------

circle = patches.Arc((0.5, 0.35), 0.25, 0.25,
                     angle=0, theta1=0, theta2=300, linewidth=1.5)
ax.add_patch(circle)

ax.annotate("", xy=(0.62, 0.38), xytext=(0.55, 0.46),
            arrowprops=dict(arrowstyle="->", linewidth=1.5))
ax.text(0.66, 0.33, "Rotations", fontsize=8, va="center")

# -----------------------------
# 5. Nube de sedimento suspendido
# -----------------------------

sediment_x = [0.45, 0.48, 0.52, 0.55, 0.47, 0.53]
sediment_y = [0.3, 0.32, 0.34, 0.29, 0.27, 0.31]
ax.scatter(sediment_x, sediment_y, s=15, color="gray")
ax.text(0.42, 0.34, "Suspended\nsediment", fontsize=8, va="bottom")

# -----------------------------
# 6. Texto de tiempo de recuperación
# -----------------------------

ax.annotate("30–45 s\nrecovery",
            xy=(0.32, 0.27),
            xytext=(0.25, 0.40),
            arrowprops=dict(arrowstyle="->", linewidth=1),
            fontsize=8, va="center")

# -----------------------------
# Ajustes finales
# -----------------------------

ax.set_xlim(0, 1)
ax.set_ylim(0.15, 0.9)
ax.set_axis_off()

fig.tight_layout()
plt.show()

# Guardar archivos (SIN INDENTACIÓN)
fig.savefig("Fig2_disturbance_protocol.png", dpi=300, bbox_inches="tight")
fig.savefig("Fig2_disturbance_protocol.svg", format="svg", bbox_inches="tight")

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Estilo general tipo "Elsevier"
plt.rcParams.update({
    "font.family": "sans-serif",
    "font.size": 9
})

# Crear figura y ejes
fig, ax = plt.subplots(figsize=(6, 1.8))

# Texto de cada bloque del flujo
steps = [
    "Load data",
    "Clean data",
    "Compute\nefficiencies",
    "Fit LMM",
    "Diagnostics"
]

# Parámetros geométricos
block_width = 1.6
block_height = 0.55
x_start = 0.3       # posición x inicial
y_block = 0.75      # posición y de los bloques (más arriba para dejar espacio abajo)

# Dibujar bloques y flechas
for i, label in enumerate(steps):
    x0 = x_start + i * (block_width + 0.4)

    # Bloque con esquinas redondeadas
    rect = patches.FancyBboxPatch(
        (x0, y_block),
        block_width,
        block_height,
        boxstyle="round,pad=0.03",
        linewidth=1.2,
        edgecolor="black",
        facecolor="none"
    )
    ax.add_patch(rect)

    # Texto centrado dentro del bloque
    ax.text(
        x0 + block_width / 2,
        y_block + block_height / 2,
        label,
        ha="center",
        va="center"
    )

    # Flecha hacia siguiente bloque
    if i < len(steps) - 1:
        x_arrow_start = x0 + block_width
        x_arrow_end = x_start + (i + 1) * (block_width + 0.4)
        ax.annotate(
            "",
            xy=(x_arrow_end, y_block + block_height / 2),
            xytext=(x_arrow_start, y_block + block_height / 2),
            arrowprops=dict(arrowstyle="->", linewidth=1.2)
        )

# -----------------------------------------------
# TEXTO INFERIOR: Perfectamente centrado
# -----------------------------------------------

pipeline_text = "Preprocessing   →   Efficiency computation   →   Mixed-effects modeling"

# Calcular centro del pipeline de pasos
pipeline_center_x = x_start + ( (len(steps)-1)*(block_width + 0.4) + block_width ) / 2

# Insertar texto centrado bajo el diagrama
ax.text(
    pipeline_center_x,
    0.33,                 # posición vertical correcta
    pipeline_text,
    ha="center",
    va="center",
    fontsize=8
)

# Ajustes de ejes
ax.set_xlim(0, x_start + len(steps) * (block_width + 0.4))
ax.set_ylim(0, 1.4)
ax.axis("off")

fig.tight_layout()

# Mostrar figura
plt.show()

# Guardar en alta resolución
fig.savefig("Fig3_analytical_workflow.png", dpi=300, bbox_inches="tight")
fig.savefig("Fig3_analytical_workflow.svg", format="svg", bbox_inches="tight")

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Estilo general tipo "Elsevier"
plt.rcParams.update({
    "font.family": "sans-serif",
    "font.size": 9
})

# Crear figura y ejes
fig, ax = plt.subplots(figsize=(6, 1.8))

# Texto de cada bloque del pseudocódigo
steps = [
    "Load data",
    "Preprocess",
    "Compute\nefficiencies",
    "Fit model",
    "Export outputs"
]

# Parámetros geométricos
block_width = 2.0
block_height = 0.55
x_start = 0.3       # posición x inicial
y_block = 0.75      # posición y de los bloques

# Dibujar bloques y flechas
for i, label in enumerate(steps):
    x0 = x_start + i * (block_width + 0.4)

    # Bloque con esquinas redondeadas
    rect = patches.FancyBboxPatch(
        (x0, y_block),
        block_width,
        block_height,
        boxstyle="round,pad=0.03",
        linewidth=1.2,
        edgecolor="black",
        facecolor="none"
    )
    ax.add_patch(rect)

    # Texto centrado dentro del bloque
    ax.text(
        x0 + block_width / 2,
        y_block + block_height / 2,
        label,
        ha="center",
        va="center"
    )

    # Flecha hacia el siguiente bloque
    if i < len(steps) - 1:
        x_arrow_start = x0 + block_width
        x_arrow_end = x_start + (i + 1) * (block_width + 0.4)
        ax.annotate(
            "",
            xy=(x_arrow_end, y_block + block_height / 2),
            xytext=(x_arrow_start, y_block + block_height / 2),
            arrowprops=dict(arrowstyle="->", linewidth=1.2)
        )

# (Opcional) Texto breve debajo, centrado, si quieres enfatizar que es pseudocode
pipeline_text = "Block-level pseudocode of the main computational steps"

# Centro horizontal del pipeline
pipeline_center_x = x_start + ((len(steps) - 1) * (block_width + 0.4) + block_width) / 2

ax.text(
    pipeline_center_x,
    0.30,                 # posición vertical
    pipeline_text,
    ha="center",
    va="center",
    fontsize=8
)

# Ajustes de ejes
ax.set_xlim(0, x_start + len(steps) * (block_width + 0.4))
ax.set_ylim(0, 1.4)
ax.axis("off")

fig.tight_layout()

# Mostrar figura
plt.show()

# Guardar en alta resolución para MethodsX
fig.savefig("Fig4_pseudocode_block_diagram.png", dpi=300, bbox_inches="tight")
fig.savefig("Fig4_pseudocode_block_diagram.svg", format="svg", bbox_inches="tight")

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# 1. Coordenadas de las estaciones
# -------------------------------
stations = {
    "S1": (-2.1504524442872683, -79.90386509307386),
    "S2": (-2.150425641089682,  -79.9036317408747),
    "S3": (-2.1507781031339674, -79.90312480337113),
    "S4": (-2.151149327332683,  -79.90247302657993),
    "S5": (-2.1514991088976423, -79.90149804361434),
}

lat0, lon0 = stations["S1"]
lat0_rad = np.deg2rad(lat0)

# Conversión a metros aproximada
m_per_deg_lat = 111_320
m_per_deg_lon = 111_320 * np.cos(lat0_rad)

def latlon_to_local(lat, lon, lat0=lat0, lon0=lon0):
    dy = (lat - lat0) * m_per_deg_lat
    dx = (lon - lon0) * m_per_deg_lon
    return dx, dy

order = ["S1", "S2", "S3", "S4", "S5"]
xs = []

for name in order:
    lat, lon = stations[name]
    dx, dy = latlon_to_local(lat, lon)
    xs.append(dx)

xs = np.array(xs)

# Normalización conceptual
xs_norm = (xs - xs.min()) / (xs.max() - xs.min())


# -------------------------------
# 2. Figura conceptual (Data in Brief)
# -------------------------------
plt.rcParams.update({"font.family": "sans-serif", "font.size": 9})

fig, ax = plt.subplots(figsize=(6.2, 2.4))

# Banda del estero
channel_y = 0.50
channel_h = 0.12

ax.add_patch(plt.Rectangle(
    (0.05, channel_y - channel_h/2),
    0.90,
    channel_h,
    facecolor="#d9edf7",
    edgecolor="black",
    linewidth=1.0
))

# Estaciones
for x_norm, name in zip(xs_norm, order):
    x_plot = 0.05 + 0.90 * x_norm
    ax.plot(x_plot, channel_y, "o", color="black", markersize=4)
    ax.text(x_plot, channel_y + 0.09, name, ha="center", va="bottom", fontsize=9)

# -------------------------------
# 3. Rectángulo Ecotec University
# -------------------------------
# Lo colocamos entre E3 y E4 en el espacio normalizado:
x_S3 = 0.05 + 0.90 * xs_norm[2]
x_S4 = 0.05 + 0.90 * xs_norm[3]

rect_x = (x_S3 + x_S4) / 2 - 0.10
rect_y = channel_y + 0.18
rect_w = 0.20
rect_h = 0.12

ax.add_patch(plt.Rectangle(
    (rect_x, rect_y),
    rect_w,
    rect_h,
    edgecolor="black",
    facecolor="white",
    linewidth=1.1
))

ax.text(rect_x + rect_w/2, rect_y + rect_h/2,
        "Ecotec University",
        ha="center", va="center", fontsize=8)

# -------------------------------
# 4. Flecha de dirección del estero
# -------------------------------
ax.annotate("",
            xy=(0.90, channel_y - 0.16),
            xytext=(0.10, channel_y - 0.16),
            arrowprops=dict(arrowstyle="->", linewidth=1.1))

ax.text(0.50, channel_y - 0.21,
        "Along-estuary direction",
        ha="center", va="top", fontsize=9)

# -------------------------------
# 5. Flecha de Norte
# -------------------------------
ax.annotate("",
            xy=(0.93, 0.85),
            xytext=(0.93, 0.70),
            arrowprops=dict(arrowstyle="->", linewidth=1.0))

ax.text(0.93, 0.87, "N", ha="center", va="bottom", fontsize=9)

# -------------------------------
# 6. Formato final
# -------------------------------
ax.set_xlim(0, 1)
ax.set_ylim(0.25, 0.95)
ax.axis("off")

fig.tight_layout()
fig.savefig("Fig1_DataInBrief_layout_Ecotec.png", dpi=300, bbox_inches="tight")
fig.savefig("Fig1_DataInBrief_layout_Ecotec.svg", format="svg", bbox_inches="tight")

plt.show()

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Estilo general tipo Elsevier
plt.rcParams.update({
    "font.family": "sans-serif",
    "font.size": 9
})

# ---------- FIGURA B: Estructura del repositorio ----------

fig, ax = plt.subplots(figsize=(5, 2.8))

# Caja raíz: Repository
root_x, root_y = 0.52, 0.8
root_w, root_h = 0.3, 0.1

root = patches.FancyBboxPatch(
    (root_x, root_y),
    root_w,
    root_h,
    boxstyle="round,pad=0.02",
    edgecolor="black",
    facecolor="none",
    linewidth=1.2
)
ax.add_patch(root)
ax.text(root_x + root_w/2, root_y + root_h/2,
        "Repository", ha="center", va="center")

# Subcarpetas
folders = [
    ("Raw data", "ECOTEC_Estuary...\n2024-2025.csv"),
    ("Metadata", "metadata.yaml"),
    ("Processing scripts", "Analysis_v1.0.py")
]

folder_w, folder_h = 0.32, 0.15
start_x = 0.09
y_folder = 0.45

for i, (title, fname) in enumerate(folders):
    fx = start_x + i * (folder_w + 0.1)
    fy = y_folder

    # Caja de carpeta
    rect = patches.FancyBboxPatch(
        (fx, fy),
        folder_w,
        folder_h,
        boxstyle="round,pad=0.02",
        edgecolor="black",
        facecolor="none",
        linewidth=1.2
    )
    ax.add_patch(rect)

    # Título de carpeta
    ax.text(fx + folder_w/2, fy + folder_h*0.75,
            title, ha="center", va="center")

    # Nombre de archivo
    ax.text(fx + folder_w/2, fy + folder_h*0.35,
            fname, ha="center", va="center")

    # Flechas desde Repository
    ax.annotate("",
                xy=(fx + folder_w/2, fy + folder_h + 0.04),
                xytext=(root_x + root_w/2, root_y - 0.05),
                arrowprops=dict(arrowstyle="->", linewidth=1))

# Ajustes finales
ax.set_xlim(0, 1.36)
ax.set_ylim(0.25, 1)
ax.axis("off")

fig.tight_layout()

# Guardar
fig.savefig("Fig2_repository_structure.png", dpi=300, bbox_inches="tight")
fig.savefig("Fig2_repository_structure.svg", format="svg", bbox_inches="tight")
plt.show()
plt.close(fig)

from google.colab import files
files.download("Fig2_repository_structure.png")

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Estilo tipo Elsevier
plt.rcParams.update({
    "font.family": "sans-serif",
    "font.size": 9
})

# ---------- FIGURA C: Data pipeline ----------

fig, ax = plt.subplots(figsize=(6.5, 2.0))  # más horizontal, menos alto

steps = [
    "Raw data\n(CSV)",
    "Preprocess\n(Python script)",
    "Cleaned dataset\n+ plots"
]

block_w = 1.9
block_h = 0.7
x_start = 0.4
y_block = 0.7
gap = 0.7

for i, label in enumerate(steps):
    x0 = x_start + i * (block_w + gap)

    # Caja
    rect = patches.FancyBboxPatch(
        (x0, y_block),
        block_w,
        block_h,
        boxstyle="round,pad=0.02",
        edgecolor="black",
        facecolor="none",
        linewidth=1.2
    )
    ax.add_patch(rect)

    # Texto centrado
    ax.text(x0 + block_w/2,
            y_block + block_h/2,
            label,
            ha="center", va="center")

    # Flecha al siguiente bloque
    if i < len(steps) - 1:
        ax.annotate(
            "",
            xy=(x0 + block_w + gap*1.0, y_block + block_h/2),
            xytext=(x0 + block_w + 0.02,  y_block + block_h/2),
            arrowprops=dict(arrowstyle="->", linewidth=1.2)
        )

# Límites del eje: aquí quitas el espacio en blanco
ax.set_xlim(0, x_start + len(steps) * (block_w + gap) - 0.2)
ax.set_ylim(0.4, 1.6)   # <- recorta la parte inferior y superior

ax.axis("off")

# Guardar
fig.savefig("Fig3_data_pipeline.png", dpi=300, bbox_inches="tight")
fig.savefig("Fig3_data_pipeline.svg", format="svg", bbox_inches="tight")

# Visualizar en Colab / Jupyter
plt.show()